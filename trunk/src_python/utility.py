import conf
import networkx
import operator

def statistics():
    G_ref = open_graph(conf.ref_graph_file)
    G_tar = open_graph(conf.target_graph_file);
    conf.n_ref_nodes = len(open(conf.ref_feature_file).readlines())
    conf.n_tar_nodes = len(open(conf.target_feature_file).readlines())
    conf.n_ref_edges = G_ref.number_of_edges()
    conf.n_tar_edges = G_tar.number_of_edges()
    return 

def report_printer(score, good_guess):
    print "\n\n\n"
    print "************************"
    print "NOTICE, THIS REPORT MIGHT BE GENERATED BY REID OR COMMUNITY_MATCHER. THERE'S NO DISTINGUISH NOW"
    print "Program ends      "
    print "Score = %d     SCORE MEAN NOTHING AT LEAST NOW  "%score
    print "Good guess=%d    "%good_guess
    print "Parameters used"
    print "Good guess rangee=%f"%conf.percentage
    print "Ref nodes # %d, tar nodes # %d, #nodes in both graphs %d"%(conf.n_ref_nodes, conf.n_tar_nodes, conf.n_common_nodes)
    print "Ref edges # %d, tar edges # %d"%(conf.n_ref_edges, conf.n_tar_edges)
    print "%d top nodes"%conf.n_top_degree_nodes
    print "Reference graph="+conf.ref_graph_file
    print "Target graph = "+conf.target_graph_file
    print "Reference feature file="+conf.ref_feature_file
    print "Target feature file="+conf.target_feature_file
    print "Nodes pool (for community_based) %f"%conf.nodes_pool_ratio
    print "Partition method = %s" % conf.partition_method
    print "cluster_sim_measure = %s" % conf.cluster_sim_measure
    print "# of partition for ref=%d, # of partition for tar=%d"%(conf.n_ref_partition, conf.n_tar_partition)
    
    if conf.partition_method != 'louvain':
        print "num_of_clusters = %d" %conf.num_of_clusters
    if conf.partition_method == 'metis':
        print "metis_args = %s"%conf.metis_args
    print "************************"
    print "\n\n\n"

def find_top_degree_nodes( ):
    """find top n nodes in terms of degree in target graph and these nodes should also be in reference graph"""
    n_top_degree_nodes = conf.n_top_degree_nodes
    print "Finding "+str(n_top_degree_nodes)+" top degree nodes"
    common_nodes = compute_common_nodes();
    print "%d common nodes are in two graphs" %len(common_nodes)
    G_tar = open_graph(conf.target_graph_file);
    degree_dic = sorted(G_tar.degree().iteritems(), key=operator.itemgetter(1), reverse=True);
    cnt = min(n_top_degree_nodes, len(common_nodes))
    r_nodes = set()
    for d in degree_dic:
        if(d[0] in common_nodes  and cnt>0):
            r_nodes |= set([d[0]]);
            cnt-=1;
    return r_nodes

def open_graph(file_name, seperator = ","):
    if(conf.undirected):
        G = networkx.readwrite.edgelist.read_weighted_edgelist(path=file_name, delimiter=seperator)
    else:
        G = networkx.readwrite.edgelist.read_weighted_edgelist(path=file_name,create_using = networkx.DiGraph(), delimiter = seperator)
    return G 

def compute_common_nodes():
    """find the co_existing nodes for two graphs."""
    ref_lines = open(conf.ref_feature_file,'r').readlines();
    target_lines = open(conf.target_feature_file, 'r').readlines()
    ref_nodes = set([line.replace('\n','').split(',')[0] for line in ref_lines]);
    target_nodes = set([line.replace('\n','').split(',')[0] for line in target_lines]);
    com_nodes = ref_nodes&target_nodes;
    conf.n_common_nodes = len(com_nodes)
    return com_nodes

def read_feature_table(feature_table_file):
    lines = open(feature_table_file,'r').readlines();
    feature_dic = {};
    for line in lines:
        t = line.replace("\n","").replace("\r",'').split(",")
        #make sure the node appears in both graph
        for i in range(1,len(t)):
            feature_dic.setdefault(t[0],[]).append(int(float(t[i])));
    return feature_dic

if __name__ == "__main__":
    compute_common_nodes()
